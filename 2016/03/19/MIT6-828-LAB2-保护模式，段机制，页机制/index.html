<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MIT6.828 LAB2 保护模式，段机制，页机制 | TommyLiu's Blog</title><link rel="stylesheet" type="text/css" href="http://tommylwp.me//css/normalize.css"><link rel="stylesheet" type="text/css" href="http://tommylwp.me//css/highlight.css"><link rel="stylesheet" type="text/css" href="http://tommylwp.me//css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="http:/tommylwp.me/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="http:/tommylwp.me/." class="title">TommyLiu's Blog</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="http:/tommylwp.me/" class="sidebar-nav-item">Home</a><a href="http:/tommylwp.me/archives" class="sidebar-nav-item">Archives</a><a href="http:/tommylwp.me/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>MIT6.828 LAB2 保护模式，段机制，页机制</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2016-03-19</div><div class="post-tags"><a class="post-tag-link" href="http:/tommylwp.me/tags/JOS/">JOS</a></div></div></div><article><div class="container post"><p>在Lab2中 我们将要建立基本的保护模式下的内存管理机制，我们有必要先弄清楚保护模式下是如何管理内存的。</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>80x86在保护模式下内存机制主要分为<strong>段机制</strong>和<strong>页机制</strong>，其中页机制是基于段机制的。</p>
<p>关于一个内存管理机制，有两个大的方面我们需要关心，一个是<strong>如何寻址</strong>，另一个是<strong>如何确定权限（即实现所谓保护）</strong>。段机制和页机制都提供了一定的寻址功能，但是其中有一定的重复。JOS没有使用段机制中的寻址功能，所有寻址只和页机制有关。段机制和页机制共同决定权限。</p>
<h2 id="段机制"><a href="#段机制" class="headerlink" title="段机制"></a>段机制</h2><h3 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h3><p>通过段选择符（selector）从段描述符表中获得段描述符，再加上offset，可以映射得到linear address(线性地址)。<br><img src="http://img.blog.csdn.net/20160319001829672" alt="这里写图片描述"></p>
<h4 id="段描述符："><a href="#段描述符：" class="headerlink" title="段描述符："></a>段描述符：</h4><p>Descriptor Table(段描述符表)是一个段描述符的数组，Segment Descriptor(段描述符)定义虚拟内存段的基本信息，如base，limit(从哪里开始，从哪里结束)，访问权限等。具体的段描述符信息如下图：<br><img src="http://img.blog.csdn.net/20160319002820481" alt="这里写图片描述"><br>由图可以看出，段描述符是一个64位长的符在JOS中我们通过inc/mmu.h下的<code>SEG</code>宏来快速定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define SEG(type, base, lim, dpl) (struct Segdesc)			\</span><br><span class="line">&#123; ((lim) &gt;&gt; 12) &amp; 0xffff, (base) &amp; 0xffff, ((base) &gt;&gt; 16) &amp; 0xff,	\</span><br><span class="line">    type, 1, dpl, 1, (unsigned) (lim) &gt;&gt; 28, 0, 0, 1, 1,		\</span><br><span class="line">    (unsigned) (base) &gt;&gt; 24 &#125;</span><br></pre></td></tr></table></figure>
<p>type：访问权限(可执行STA_X，可读STA_R，可写STA_W)<br>base：基地址，在JOS中所有段描述符的基地址都定义为0<br>lim：长度，都定义为0xFFFFFFFF<br>dpl : DESCRIPTOR PRIVILEGE LEVEL（描述符权限级别），在*nix系统中分为0-3（越低权限越高），0为kernel态，1-3为用户态。在JOS中定义了0(kernel态)和3(user态)（Linux也是这样定义的）。</p>
<p>在kern/env.c中定义了<strong>段描述符表<code>gdc</code></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">struct Segdesc gdt[NCPU + 5] =</span><br><span class="line">&#123;</span><br><span class="line">	// 0x0 - unused (always faults -- for trapping NULL far pointers)</span><br><span class="line">	SEG_NULL,</span><br><span class="line"></span><br><span class="line">	// 0x8 - kernel code segment</span><br><span class="line">	[GD_KT &gt;&gt; 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 0),</span><br><span class="line"></span><br><span class="line">	// 0x10 - kernel data segment</span><br><span class="line">	[GD_KD &gt;&gt; 3] = SEG(STA_W, 0x0, 0xffffffff, 0),</span><br><span class="line"></span><br><span class="line">	// 0x18 - user code segment</span><br><span class="line">	[GD_UT &gt;&gt; 3] = SEG(STA_X | STA_R, 0x0, 0xffffffff, 3),</span><br><span class="line"></span><br><span class="line">	// 0x20 - user data segment</span><br><span class="line">	[GD_UD &gt;&gt; 3] = SEG(STA_W, 0x0, 0xffffffff, 3),</span><br><span class="line"></span><br><span class="line">	// Per-CPU TSS descriptors (starting from GD_TSS0) are initialized</span><br><span class="line">	// in trap_init_percpu()</span><br><span class="line">	[GD_TSS0 &gt;&gt; 3] = SEG_NULL</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="段选择符（selector）："><a href="#段选择符（selector）：" class="headerlink" title="段选择符（selector）："></a>段选择符（selector）：</h4><p><img src="http://img.blog.csdn.net/20160319004254109" alt="这里写图片描述"><br><img src="http://img.blog.csdn.net/20160319004605036" alt="这里写图片描述"></p>
<h4 id="寻址总结"><a href="#寻址总结" class="headerlink" title="寻址总结"></a>寻址总结</h4><p>段机制的寻址总的来说就是把虚拟地址（这里是offset映射到线性地址上）即 <code>Linear Address=Base+Offset</code>。由于段描述符定义的<code>base=0</code>，所以有：<code>Linear Address=Offset</code></p>
<h2 id="页机制"><a href="#页机制" class="headerlink" title="页机制"></a>页机制</h2><h3 id="概述：-1"><a href="#概述：-1" class="headerlink" title="概述："></a>概述：</h3><p>页机制通过多层页表，把Linear Address映射到实际内存地址空间。</p>
<h4 id="Linear-Address："><a href="#Linear-Address：" class="headerlink" title="Linear Address："></a>Linear Address：</h4><p><img src="http://img.blog.csdn.net/20160319010352559" alt="这里写图片描述"></p>
<p>线性地址（linear address）是一个32位长的数，DIR(10位长)是在第一层页表中的index，PAGE是在第二层页表中的index（10位长），OFFSET是在该页中的偏移量（12位长）。由此我们可以看出，第一层页表有1024项，第二层页表也有1024项，一个单独的页（one page）的大小时4K。</p>
<p>具体的寻址方式见：<br><img src="http://img.blog.csdn.net/20160319010900471" alt="这里写图片描述"><br>其中CR3是一个寄存器，用来存放第一层页表（Page Directory）的基地址。</p>
<p>总结：由于禁用了段机制的寻址功能（只用来做访问控制），实际用户和开发者使用的（虚拟）地址（virtual memory）即等于线性地址（Linear Address），再通过两层页表，最终映射到了物理地址（Physical Address）空间。</p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p>1.<a href="http://www.logix.cz/michal/doc/i386/chp05-00.htm" target="_blank" rel="external">Intel 80386 Programmer’s Reference Manual</a><br>2.<a href="http://guojing.me/linux-kernel-architecture/posts/segment-selector/" target="_blank" rel="external">GuoJing’s Blog/linux-kernel-architecture/segment-selector</a></p>
</div><!-- comment system--><div class="container"><hr><div data-thread-key="2016/03/19/MIT6-828-LAB2-保护模式，段机制，页机制/" data-title="MIT6.828 LAB2 保护模式，段机制，页机制" data-url="https://github.com/T0mmyliuhttp:/tommylwp.me/2016/03/19/MIT6-828-LAB2-保护模式，段机制，页机制/" class="ds-thread"></div><script>var duoshuoQuery = {short_name:'tommyliu'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="https://github.com/https://github.com/t0mmyliu" target="_blank"><i class="fa fa-github"></i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2016 <a href="/" rel="nofollow"></a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/lotabout/very-simple">very-simple</a>.</div></div></div></footer></body></html>