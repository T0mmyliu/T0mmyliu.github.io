<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>MIT6.828 LAB1 bootloader 加载操作系统 | TommyLiu's Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/very-simple.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"></head><body><!-- include the sidebar--><!-- include ./includes/sidebar.jade--><!-- Blog title and subtitle--><header><div class="container header"><a id="logo" href="/." class="title">TommyLiu's Blog</a><span class="subtitle"></span><label id="toggle-menu" for="menu" onclick><i class="fa fa-bars"></i></label></div></header><!-- use checkbox hack for toggle nav-bar on small screens--><input id="menu" type="checkbox"><!-- Navigation Links--><nav id="nav"><div class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/timelines" class="sidebar-nav-item">Timelines</a><a href="/about" class="sidebar-nav-item">About</a></div></nav><div id="header-margin-bar"></div><!-- gallery that comes before the header--><div class="wrapper"><div class="container post-header"><h1>MIT6.828 LAB1 bootloader 加载操作系统</h1></div></div><div class="wrapper"><div class="container meta"><div class="post-time">2016-03-19</div><div class="post-tags"><a class="post-tag-link" href="/tags/JOS/">JOS</a></div></div></div><article><div class="container post"><h3 id="MIT-6-828课程正式开始-D-撒花"><a href="#MIT-6-828课程正式开始-D-撒花" class="headerlink" title="MIT 6.828课程正式开始 :-D 撒花"></a>MIT 6.828课程正式开始 :-D 撒花</h3><h2 id="Part-1：PC-Bootstrap"><a href="#Part-1：PC-Bootstrap" class="headerlink" title="Part 1：PC Bootstrap"></a>Part 1：PC Bootstrap</h2><p>这一部分主要介绍如何用qemu和gdb联调kernel :-D。<br>打开两个terminal，都进入到lab目录，然后其中一个输入make qemu-gdb，另一个输入make gdb，即可，你可以看到下面的画面:<br><img src="http://img.blog.csdn.net/20160224082044678" alt="这里写图片描述"></p>
<p>刚启动时，计算机处于实模式。可以看到，当机器刚上电时候，此时PC指向的地址是0xffff0，这是硬件工程师故意这样做的。第一条指令是一个长跳转指令，这条指令是跳向BIOS的开头。你可以继续使用<strong>SI</strong> 命令继续逐条观察，这部分都是BIOS做的工作，大概是通过IO check 各种硬件(reference 里的手册真长)，比较的晦涩（以及无聊，所以我大概看了看就略过了…）。</p>
<h2 id="Part-2-The-bootloader"><a href="#Part-2-The-bootloader" class="headerlink" title="Part 2: The bootloader"></a>Part 2: The bootloader</h2><p>BIOS做的最后一件事情是</p>
<blockquote>
<p>Eventually, when it finds a bootable disk, the BIOS reads the boot loader from the disk and transfers control to it.</p>
</blockquote>
<p>就是BIOS帮我们读了一个扇区（sector）的代码到0x7c00 这个地方，然后跳转到这个地方。这个扇区的代码就是JOS的bootloader。</p>
<p>JOS的bootloader有两部分，先是一段汇编代码，在 boot/boot.S里面，然后是一个C源代码，在boot/main.c。</p>
<p>##</p>
<p>我们依次来分析这两段代码。</p>
<h4 id="boot-boot-S-从实模式到保护模式"><a href="#boot-boot-S-从实模式到保护模式" class="headerlink" title="boot/boot.S 从实模式到保护模式"></a>boot/boot.S 从实模式到保护模式</h4><p>正如boot.S里的注释第一句</p>
<blockquote>
<h4 id="Start-the-CPU-switch-to-32-bit-protected-mode-jump-into-C"><a href="#Start-the-CPU-switch-to-32-bit-protected-mode-jump-into-C" class="headerlink" title="Start the CPU: switch to 32-bit protected mode, jump into C."></a>Start the CPU: switch to 32-bit protected mode, jump into C.</h4></blockquote>
<p>这段代码的功能就是从实模式切换到保护模式。<br>我们跳过前面的一些准备代码(tips：boot.S这段代码里有一段是A20的设置，跳过他。<br>)，直接看到48行左右，这才是<strong>关键</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lgdt    gdtdesc</span><br><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></table></figure>
<p>其中第一行代码是加载一个段描述符表，这是进入保护模式前必要的一步，因为保护模式的内存机制以段机制为基础（在加上页机制），具体可以参考我写的这篇：<a href="http://blog.csdn.net/poundssss/article/details/50927651" target="_blank" rel="external"> JOS Lab2 保护模式下的内存映射机制：段机制 页机制。
</a><br>这里的gdtdesc定义在最后面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gdt:</span><br><span class="line">  SEG_NULL				# null seg</span><br><span class="line">  SEG(STA_X|STA_R, 0x0, 0xffffffff)	# code seg</span><br><span class="line">  SEG(STA_W, 0x0, 0xffffffff)	        # data seg</span><br><span class="line"></span><br><span class="line">gdtdesc:</span><br><span class="line">  .word   0x17                            # sizeof(gdt) - 1</span><br><span class="line">  .long   gdt                             # address gdt</span><br></pre></td></tr></table></figure>
<p>这是一个最简单版本的段描述符，仅仅把内存分为数据段（data seg）和代码段（code seg）。</p>
<p>接下来三句代码，实现的功能就是实模式到保护模式。(其实就是改变了CR0寄存器里的一位，从0变成了1。)<br>关于CR0寄存器，<a href="https://en.wikipedia.org/wiki/Control_register" target="_blank" rel="external">自己去wiki看啦。</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl    %cr0, %eax</span><br><span class="line">orl     $CR0_PE_ON, %eax</span><br><span class="line">movl    %eax, %cr0</span><br></pre></td></tr></table></figure></p>
<p>然后通过一个ljmp跳到了<strong>prtcseg</strong>这一段代码里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movw    $PROT_MODE_DSEG, %ax    # Our data segment selector</span><br><span class="line">movw    %ax, %ds                # -&gt; DS: Data Segment</span><br><span class="line">movw    %ax, %es                # -&gt; ES: Extra Segment</span><br><span class="line">movw    %ax, %fs                # -&gt; FS</span><br><span class="line">movw    %ax, %gs                # -&gt; GS</span><br><span class="line">movw    %ax, %ss                # -&gt; SS: Stack Segment</span><br></pre></td></tr></table></figure>
<p>随便设了一些segment的base值，下一句代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">movl    $start, %esp</span><br></pre></td></tr></table></figure>
<p><strong>这句代码很重要</strong>，这是进入保护模式之后第一个栈顶，<strong>$start</strong>的地址大概在<code>0x7c00</code> 后多一些，这个随便取的，在正式的设定之前，0-start 这段空间做为栈，应该足够了:-D。<br><strong>有了栈，我们可以调用函数了！</strong><br>于是下一句  <code>call bootmain</code>我们进入<strong>main.c</strong></p>
<h4 id="boot-main-c-勤劳的搬运工"><a href="#boot-main-c-勤劳的搬运工" class="headerlink" title="boot/main.c 勤劳的搬运工"></a>boot/main.c 勤劳的搬运工</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ELFHDR		((struct Elf *) 0x10000) // scratch space</span><br></pre></td></tr></table></figure>
<p>首先定义了一个ELFHDR的量，ELF文件的头文件。ELF是一类文件格式的名称，我们的kernel就是ELF，后续还会有很多地方会用到这个ELF，所以你有必要搞明白他，越早越好-&gt;<a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format" target="_blank" rel="external">wiki是你的朋友。</a><br>反正这一段代码就是根据elf hear里的信息，一段一段的把kernel的代码搬运到内存，从0x10000（1M）(这里还是物理内存地址)开始。理解起来挺容易，中间的一个强制类型转换可能会引起困扰：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ph = (struct Proghdr *) ((uint8_t *) ELFHDR + ELFHDR-&gt;e_phoff);</span><br></pre></td></tr></table></figure>
<p>其中的(uint8_t <em>)是为了让ELFHDR指针每+1增加1而不是32位指针默认的+4。<br>最后一行`    ((void (</em>)(void)) (ELFHDR-&gt;e_entry))();`在elfhdr中，定义了一个入口地址，call它，我们就开始运行kernel的第一行代码，从这里开始bootloader结束。</p>
<h4 id="kern-entry-S-内核！内核！"><a href="#kern-entry-S-内核！内核！" class="headerlink" title="kern/entry.S 内核！内核！"></a>kern/entry.S 内核！内核！</h4><p>哈哈哈哈，我们从boot文件夹跳到了kern文件夹，这意味着，我们终于进入内核啦！撒花~</p>
<p>冷静下来继续读代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">movl	$(RELOC(entry_pgdir)), %eax</span><br><span class="line">movl	%eax, %cr3</span><br><span class="line"># Turn on paging.</span><br><span class="line">movl	%cr0, %eax</span><br><span class="line">orl	$(CR0_PE|CR0_PG|CR0_WP), %eax</span><br><span class="line">movl	%eax, %cr0</span><br></pre></td></tr></table></figure>
<p>由于虚拟内存机制还没建立(lab2做这事儿)，所以老师帮我们手写了4MB的页表，在<strong>kern/entrypgdir.c</strong>里面，大概功能就是把1M-5M这段物理地址同时映射到从0x10000和0xF0000000开始的高（虚拟）地址中（我们的内核将来就处于从这里开始的256M空间中。）把entry_pgdir加载到cr3寄存器（用来存放页表一级目录基地址的寄存器）。然后打开cr0的页机制（同时打开的还有wp，自己wiki cr0吧…）。</p>
<blockquote>
<p>Now paging is enabled, but we’re still running at a low EIP<br>    (why is this okay?).</p>
</blockquote>
<p>注释里这样问，为什么可以呢？因为…老师帮我们同时map了原来的地址和加上0xf0000000两段，也就是在虚拟内存里有2个4M空间（好绕口…我实在不知道怎么表述）。 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">movl	$0x0,%ebp			# nuke frame pointer</span><br><span class="line"></span><br><span class="line"># Set the stack pointer</span><br><span class="line">movl	$(bootstacktop),%esp</span><br><span class="line"></span><br><span class="line"># now to C code</span><br><span class="line">call	i386_init</span><br></pre></td></tr></table></figure>
<p>这里建立了虚拟地址下的栈基地址（随便定的啦…就定0好了）和栈顶地址<strong>bootstacktop</strong>。这里是建立了保护模式下（简单的）虚拟内存机制（lab2建立完整的）后的栈。于是我们可以调用函数啦，:-D。<br>于是我们就</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">call	i386_init</span><br></pre></td></tr></table></figure>
<p>开始初始化工作，基本就没有lab1什么事了，到lab4之前基本上都在完善i386_init里的内容，建立内存机制，建立进程（JOS里叫运行环境environment），建立多CPU啦啦啦~</p>
<p>#-EOF</p>
</div><!-- comment system--><div class="container"><hr><div data-thread-key="2016/03/19/JOS lab1 boot 加载操作系统/" data-title="MIT6.828 LAB1 bootloader 加载操作系统" data-url="https://github.com/T0mmyliu/2016/03/19/JOS lab1 boot 加载操作系统/" class="ds-thread"></div><script>var duoshuoQuery = {short_name:'tommyliu'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script></div></article><footer id="footer"><div class="container"><div class="bar"><div class="social"><a href="https://github.com/https://github.com/t0mmyliu" target="_blank"><i class="fa fa-github"></i></a><a href="/atom.xml" target="_blank"><i class="fa fa-rss"></i></a></div><div class="footer">© 2016 <a href="/" rel="nofollow"></a>. Powered by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo</a>. Theme <a target="_blank" href="https://github.com/T0mmyliu/very-simple">TooSimple</a>.</div></div></div></footer></body></html>